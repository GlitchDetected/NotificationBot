/* eslint-disable @typescript-eslint/no-explicit-any */
import { BskyAgent } from "@atproto/api";
import axios from "axios";

import type { ContentData, notificationConfig, NotificationType } from "@/typings";

import appConfig from "../config";

const agent = new BskyAgent({ service: "https://bsky.social" });

axios.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 403) {
            // Ignore all 403s globally
            return Promise.resolve({ data: null });
        }
        return Promise.reject(error);
    }
);

async function bskySession() {
    if (!agent.session) {
        await agent.login({
            identifier: appConfig.apiSecrets.blueskyIdentifier,
            password: appConfig.apiSecrets.blueskyPassword
        });
    }
}

async function getRedditToken() {
    const clientId = appConfig.apiSecrets.redditClientId;
    const clientSecret = appConfig.apiSecrets.redditClientSecret;
    const username = appConfig.apiSecrets.redditUsername;
    const password = appConfig.apiSecrets.redditPassword;

    const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString("base64");

    const tokenResp = await axios.post(
        "https://www.reddit.com/api/v1/access_token",
        new URLSearchParams({ grant_type: "password", username, password }).toString(),
        {
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                Authorization: `Basic ${basicAuth}`,
                "User-Agent": `NotificationBot/1.0 (by u/${appConfig.apiSecrets.redditUsername})`
            }
        }
    );

    return tokenResp.data.access_token;
}

// YouTube
async function fetchLatestYouTubeContent(config: notificationConfig): Promise<ContentData | null> {
    try {
        const apiKey = appConfig.apiSecrets.youtubeAPI;
        if (!apiKey) {
            console.error("Missing YouTube API key");
            throw new Error("Missing YouTube API key");
        }

        const url = `https://www.googleapis.com/youtube/v3/search?key=${apiKey}&channelId=${config.creator_id}&part=snippet,id&order=date&maxResults=1&type=video`;
        console.log(`Fetching YouTube videos from: ${url.replace(apiKey, "API_KEY_HIDDEN")}`);

        const response = await axios.get(url);
        console.log(`YouTube API response status: ${response.status}`);
        console.log("YouTube API response data:", JSON.stringify(response.data, null, 2));

        const item = response.data.items?.[0];
        if (!item) {
            console.warn("No videos found in YouTube response");
            return null;
        }

        const videoId = item.id.videoId;
        const snippet = item.snippet;

        const videoUrl = `https://www.googleapis.com/youtube/v3/videos?key=${apiKey}&id=${videoId}&part=statistics,snippet`;
        const videoDetailsResp = await axios.get(videoUrl);
        const videoDetails = videoDetailsResp.data.items?.[0];

        if (!videoDetails) {
            console.warn("No video details found");
            return null;
        }

        return {
            id: videoId,
            videoTitle: snippet.title,
            videoId,
            timestamp: Math.floor(new Date(snippet.publishedAt).getTime() / 1000),
            subscriberCount: videoDetails.statistics?.subscriberCount || "0",
            videoCount: videoDetails.statistics?.videoCount || "0",
            viewCount: videoDetails.statistics?.viewCount || "0",
            channelUrl: `https://youtube.com/channel/${config.creator_id}`,
            link: `https://youtube.com/watch?v=${videoId}`
        };
    } catch (err: any) {
        // Log the error details instead of silently ignoring
        if (axios.isAxiosError(err)) {
            console.error("YouTube API Error:", {
                status: err.response?.status,
                statusText: err.response?.statusText,
                data: err.response?.data,
                message: err.message
            });

            // Check if it's a quota error
            if (err.response?.status === 403) {
                const errorData = err.response.data;
                if (errorData?.error?.errors?.[0]?.reason === "quotaExceeded") {
                    console.error("YouTube API quota exceeded!");
                }
            }
        } else {
            console.error("YouTube fetch error:", err);
        }

        return null;
    }
}

// Twitch
async function fetchLatestTwitchContent(config: notificationConfig): Promise<ContentData | null> {
    try {
        const clientId = appConfig.apiSecrets.twitchClientId;
        const clientSecret = appConfig.apiSecrets.twitchClientSecret;
        if (!clientId || !clientSecret) throw new Error("Missing Twitch credentials");

        const tokenResp = await axios.post(`https://id.twitch.tv/oauth2/token?client_id=${clientId}&client_secret=${clientSecret}&grant_type=client_credentials`);
        const accessToken = tokenResp.data.access_token;

        const username = config.creator?.username || (config as any).creatorHandle;
        if (!username) throw new Error("Missing username");

        if (!username) {
            return null;
        }

        const userResp = await axios.get(`https://api.twitch.tv/helix/users?login=${username}`, {
            headers: { "Client-ID": clientId, Authorization: `Bearer ${accessToken}` }
        });
        const user = userResp.data.data?.[0];
        if (!user) return null;

        const streamResp = await axios.get(`https://api.twitch.tv/helix/streams?user_id=${user.id}`, {
            headers: { "Client-ID": clientId, Authorization: `Bearer ${accessToken}` }
        });
        const stream = streamResp.data.data?.[0];
        if (!stream) return null; // if offline

        return {
            id: stream.id,
            title: stream.title,
            game: stream.game_name,
            thumbnail: stream.thumbnail_url.replace("{width}", "640").replace("{height}", "360"),
            startedAt: Math.floor(new Date(stream.started_at).getTime() / 1000),
            link: `https://twitch.tv/${username}`
        };
    } catch (err) {
        console.error("Twitch fetch error:", err);
        return null;
    }
}

// Bluesky
export async function fetchLatestBlueskyContent(
    config: notificationConfig
): Promise<ContentData | null> {
    try {
        await bskySession();

        const blueskyHandle = config.creator?.username || (config as any).creatorHandle;
        if (!blueskyHandle) throw new Error("Missing blueskyHandle");

        const feed = await agent.getAuthorFeed({ actor: blueskyHandle, limit: 1 });
        const item = feed.data.feed?.[0];
        if (!item) return null;

        const post = item.post; // PostView
        const author = post.author; // ProfileViewBasic

        return {
            id: post.cid,
            type: post.$type,
            text: (post.record as any)?.text || "",
            timestamp: Math.floor(new Date(post.indexedAt).getTime() / 1000),
            creator: {
                posts: (author as any).postsCount || 0,
                followers: (author as any).followersCount || 0
            },
            link: `https://bsky.app/profile/${blueskyHandle}/post/${post.cid}`
        };
    } catch (err) {
        console.error("Bluesky fetch error:", err);
        return null;
    }
}


// reddit
async function fetchLatestRedditContent(config: notificationConfig): Promise<ContentData | null> {
    try {
        const subreddit = config.creator?.username || (config as any).creatorHandle;
        if (!subreddit) throw new Error("Missing subreddit name");

        const token = await getRedditToken();

        const response = await axios.get(
            `https://oauth.reddit.com/r/${subreddit}/new.json?limit=1&raw_json=1`,
            {
                headers: {
                    Authorization: `Bearer ${token}`,
                    "User-Agent": `web:notificationbot:v1.0.0 (by /u/${appConfig.apiSecrets.redditUsername})`,
                    Accept: "application/json"
                },
                validateStatus: () => true
            }
        );

        const post = response.data?.data?.children?.[0]?.data;
        if (!post) {
            console.warn(`[Reddit] No valid post found for: r/${subreddit}`, response.data);
            return null;
        }

        return {
            id: post.id,
            title: post.title,
            text: post.selftext || "",
            thumbnail: post.thumbnail && post.thumbnail.startsWith("http") ? post.thumbnail : "",
            flair: post.link_flair_text || "",
            timestamp: Math.floor(post.created_utc),
            author: {
                username: post.author,
                id: post.author_fullname || ""
            },
            subreddit: {
                name: `r/${subreddit}`,
                id: post.subreddit_id,
                members: "0"
            },
            link: `https://reddit.com${post.permalink}`
        };
    } catch (err) {
        console.error("Reddit fetch error:", err);
        return null;
    }
}

// GitHub
async function fetchLatestGitHubContent(config: notificationConfig): Promise<ContentData | null> {
    try {
        const repoHandle = config.creator?.username || (config as any).creatorHandle;
        if (!repoHandle) throw new Error("Missing repository handle");

        const [owner, repo] = repoHandle.split("/");
        if (!owner || !repo) throw new Error("Invalid repository format");

        // GitHub API doesn't require authentication for public repos
        const headers: Record<string, string> = {
            Accept: "application/vnd.github.v3+json",
            "User-Agent": "NotificationBot/1.0"
        };

        if (appConfig.apiSecrets.githubToken) {
            headers["Authorization"] = `Bearer ${appConfig.apiSecrets.githubToken}`;
        }

        // Fetch latest release
        const releaseResp = await axios.get(
            `https://api.github.com/repos/${owner}/${repo}/releases/latest`,
            {
                headers,
                validateStatus: (status) => status === 200 || status === 404
            }
        );

        if (releaseResp.status === 200 && releaseResp.data) {
            const release = releaseResp.data;
            return {
                id: release.id.toString(),
                title: release.name || release.tag_name,
                text: release.body || "",
                tag: release.tag_name,
                timestamp: Math.floor(new Date(release.published_at).getTime() / 1000),
                author: {
                    username: release.author.login,
                    avatarUrl: release.author.avatar_url
                },
                repository: {
                    name: `${owner}/${repo}`,
                    stars: 0,
                    url: `https://github.com/${owner}/${repo}`
                },
                link: release.html_url
            };
        }

        // If no releases, fetch latest commit from default branch
        const repoResp = await axios.get(
            `https://api.github.com/repos/${owner}/${repo}`,
            { headers }
        );

        if (!repoResp.data) return null;

        const defaultBranch = repoResp.data.default_branch || "main";

        const commitResp = await axios.get(
            `https://api.github.com/repos/${owner}/${repo}/commits/${defaultBranch}`,
            { headers }
        );

        if (!commitResp.data) return null;

        const commit = commitResp.data;

        return {
            id: commit.sha,
            title: commit.commit.message.split("\n")[0], // First line of commit message
            text: commit.commit.message,
            timestamp: Math.floor(new Date(commit.commit.author.date).getTime() / 1000),
            author: {
                username: commit.author?.login || commit.commit.author.name,
                avatarUrl: commit.author?.avatar_url || ""
            },
            repository: {
                name: `${owner}/${repo}`,
                stars: repoResp.data.stargazers_count || 0,
                url: `https://github.com/${owner}/${repo}`
            },
            link: commit.html_url
        };

    } catch (err) {
        console.error("GitHub fetch error:", err);
        return null;
    }
}

export const fetchers: Record<
    NotificationType,
    (config: notificationConfig) => Promise<ContentData | null>
> = {
    0: fetchLatestYouTubeContent,
    1: fetchLatestTwitchContent,
    2: fetchLatestBlueskyContent,
    3: fetchLatestRedditContent,
    4: fetchLatestGitHubContent
};